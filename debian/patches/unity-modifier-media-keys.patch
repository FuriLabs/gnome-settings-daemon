--- a/plugins/common/gsd-keygrab.c
+++ b/plugins/common/gsd-keygrab.c
@@ -170,6 +170,7 @@
              key->keysym != GDK_KEY_Pause &&
              key->keysym != GDK_KEY_Print &&
              key->keysym != GDK_KEY_Scroll_Lock &&
+             key->keysym != GDK_KEY_Caps_Lock &&
              key->keysym != GDK_KEY_Pause &&
              key->keysym != GDK_KEY_Break &&
              key->keysym != GDK_KEY_Menu) {
@@ -239,19 +240,192 @@
         g_array_free (all_mods, TRUE);
 }
 
+static void
+get_keys_for_bit (guint  bit,
+                  guint *left,
+                  guint *right)
+{
+	guint left_dummy;
+	guint right_dummy;
+
+	if (left == NULL)
+		left = &left_dummy;
+	if (right == NULL)
+		right = &right_dummy;
+
+	*left = 0;
+	*right = 0;
+
+	switch (1 << bit) {
+	case GDK_SHIFT_MASK:
+		*left = GDK_KEY_Shift_L;
+		*right = GDK_KEY_Shift_R;
+		break;
+	case GDK_CONTROL_MASK:
+		*left = GDK_KEY_Control_L;
+		*right = GDK_KEY_Control_R;
+		break;
+	case GDK_LOCK_MASK:
+		*left = GDK_KEY_Caps_Lock;
+		*right = GDK_KEY_Shift_Lock;
+		break;
+	case GDK_META_MASK:
+	case GDK_MOD1_MASK:
+		*left = GDK_KEY_Alt_L;
+		*right = GDK_KEY_Alt_R;
+		break;
+	case GDK_SUPER_MASK:
+		*left = GDK_KEY_Super_L;
+		*right = GDK_KEY_Super_R;
+		break;
+	}
+}
+
+static guint
+get_mask_for_key (guint key)
+{
+	switch (key) {
+	case GDK_KEY_Shift_L:
+	case GDK_KEY_Shift_R:
+		return GDK_SHIFT_MASK;
+	case GDK_KEY_Control_L:
+	case GDK_KEY_Control_R:
+		return GDK_CONTROL_MASK;
+	case GDK_KEY_Caps_Lock:
+	case GDK_KEY_Shift_Lock:
+		return GDK_LOCK_MASK;
+	case GDK_KEY_Meta_L:
+	case GDK_KEY_Meta_R:
+	case GDK_KEY_Alt_L:
+	case GDK_KEY_Alt_R:
+		return GDK_MOD1_MASK;
+	case GDK_KEY_Super_L:
+	case GDK_KEY_Super_R:
+		return GDK_SUPER_MASK;
+	}
+
+	return 0;
+}
+
 void
 grab_key_unsafe (Key             *key,
                  GsdKeygrabFlags  flags,
                  GSList          *screens)
 {
+        guint key_mask = get_mask_for_key (key->keysym);
+
         grab_key_internal (key, TRUE, flags, screens);
+
+        if (key_mask != 0) {
+                Key copy;
+                guint i, j;
+
+                for (i = 0; i < 8 * sizeof (guint); i++) {
+                        guint left, right;
+                        gint left_keys_len, right_keys_len;
+                        GdkKeymapKey *left_keys, *right_keys;
+
+                        if (1 << i == key_mask || (key->state & 1 << i) == 0)
+                                continue;
+
+                        get_keys_for_bit (i, &left, &right);
+
+                        if (left == 0 && right == 0)
+                                continue;
+
+                        left_keys_len = 0;
+                        right_keys_len = 0;
+                        left_keys = NULL;
+                        right_keys = NULL;
+
+                        if (left != 0)
+                                gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (),
+                                                                   left,
+                                                                   &left_keys,
+                                                                   &left_keys_len);
+
+                        if (right != 0)
+                                gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (),
+                                                                   right,
+                                                                   &right_keys,
+                                                                   &right_keys_len);
+
+                        copy.keysym = left != 0 ? left : right;
+                        copy.state = (key->state | key_mask) & ~(1 << i);
+                        copy.keycodes = g_new0 (guint, left_keys_len + right_keys_len + 1);
+
+                        for (j = 0; j < left_keys_len; j++)
+                                copy.keycodes[j] = left_keys[j].keycode;
+                        for (j = 0; j < right_keys_len; j++)
+                                copy.keycodes[left_keys_len + j] = right_keys[j].keycode;
+
+                        grab_key_internal (&copy, TRUE, flags, screens);
+
+                        g_free (copy.keycodes);
+                        g_free (right_keys);
+                        g_free (left_keys);
+                }
+        }
 }
 
 void
 ungrab_key_unsafe (Key    *key,
                    GSList *screens)
 {
+        guint key_mask = get_mask_for_key (key->keysym);
+
         grab_key_internal (key, FALSE, 0, screens);
+
+        if (key_mask != 0) {
+                Key copy;
+                guint i, j;
+
+                for (i = 0; i < 8 * sizeof (guint); i++) {
+                        guint left, right;
+                        gint left_keys_len, right_keys_len;
+                        GdkKeymapKey *left_keys, *right_keys;
+
+                        if (1 << i == key_mask || (key->state & 1 << i) == 0)
+                                continue;
+
+                        get_keys_for_bit (i, &left, &right);
+
+                        if (left == 0 && right == 0)
+                                continue;
+
+                        left_keys_len = 0;
+                        right_keys_len = 0;
+                        left_keys = NULL;
+                        right_keys = NULL;
+
+                        if (left != 0)
+                                gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (),
+                                                                   left,
+                                                                   &left_keys,
+                                                                   &left_keys_len);
+
+                        if (right != 0)
+                                gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (),
+                                                                   right,
+                                                                   &right_keys,
+                                                                   &right_keys_len);
+
+                        copy.keysym = left != 0 ? left : right;
+                        copy.state = (key->state | key_mask) & ~(1 << i);
+                        copy.keycodes = g_new0 (guint, left_keys_len + right_keys_len + 1);
+
+                        for (j = 0; j < left_keys_len; j++)
+                                copy.keycodes[j] = left_keys[j].keycode;
+                        for (j = 0; j < right_keys_len; j++)
+                                copy.keycodes[left_keys_len + j] = right_keys[j].keycode;
+
+                        grab_key_internal (&copy, FALSE, 0, screens);
+
+                        g_free (copy.keycodes);
+                        g_free (right_keys);
+                        g_free (left_keys);
+                }
+        }
 }
 
 static gboolean
@@ -333,8 +507,9 @@
 	if (gdk_keymap_translate_keyboard_state (gdk_keymap_get_default (), keycode,
 						 state, group,
 						 &keyval, NULL, NULL, &consumed)) {
+		guint key_bit, event_bit;
 		guint lower, upper;
-		guint mask;
+		guint mask, full_mask;
 
 		/* HACK: we don't want to use SysRq as a keybinding, so we avoid
 		 * its translation from Alt+Print. */
@@ -346,20 +521,33 @@
 
 		/* The Key structure contains virtual modifiers, whereas
 		 * the XEvent will be using the real modifier, so translate those */
+		key_bit = get_mask_for_key (key->keysym);
+		event_bit = get_mask_for_key (keyval);
 		mask = key->state;
+		full_mask = mask | key_bit;
 		gdk_keymap_map_virtual_modifiers (gdk_keymap_get_default (), &mask);
+		gdk_keymap_map_virtual_modifiers (gdk_keymap_get_default (), &full_mask);
                 mask &= ~(GDK_META_MASK | GDK_SUPER_MASK | GDK_HYPER_MASK);
+                full_mask &= ~(GDK_META_MASK | GDK_SUPER_MASK | GDK_HYPER_MASK);
 
 		gdk_keyval_convert_case (keyval, &lower, &upper);
 
 		/* If we are checking against the lower version of the
 		 * keysym, we might need the Shift state for matching,
 		 * so remove it from the consumed modifiers */
-		if (lower == key->keysym)
+		if (lower == key->keysym || event_bit != 0)
 			consumed &= ~GDK_SHIFT_MASK;
 
-		return ((lower == key->keysym || upper == key->keysym)
-			&& (state & ~consumed & gsd_used_mods) == mask);
+		state &= ~consumed & gsd_used_mods;
+
+		if (key_bit != 0 && event_bit != 0) {
+			state |= event_bit;
+			gdk_keymap_map_virtual_modifiers (gdk_keymap_get_default (), &state);
+			state &= ~(GDK_META_MASK | GDK_SUPER_MASK | GDK_HYPER_MASK);
+			return state == full_mask;
+		}
+
+		return (lower == key->keysym || upper == key->keysym) && state == mask;
 	}
 
 	/* The key we passed doesn't have a keysym, so try with just the keycode */
