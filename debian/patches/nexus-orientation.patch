## Description: Autorotate Nexus screen
## Origin/Author: jani@ubuntu.com
## Bug: https://bugs.launchpad.net/ubuntu-nexus7/+bug/1110360
Index: gnome-settings-daemon-3.6.4/plugins/orientation/gsd-orientation-manager.c
===================================================================
--- gnome-settings-daemon-3.6.4.orig/plugins/orientation/gsd-orientation-manager.c	2013-01-10 15:37:58.000000000 +0200
+++ gnome-settings-daemon-3.6.4/plugins/orientation/gsd-orientation-manager.c	2013-01-30 14:13:41.970451866 +0200
@@ -23,6 +23,7 @@
 
 #include "config.h"
 
+#include <fcntl.h>
 #include <glib.h>
 #include <gtk/gtk.h>
 #include <gdk/gdk.h>
@@ -372,12 +373,14 @@
 static GUdevDevice *
 get_accelerometer (GUdevClient *client)
 {
-        GList *list, *l;
+        GList *list, *listiio, *l;
         GUdevDevice *ret, *parent;
 
         /* Look for a device with the ID_INPUT_ACCELEROMETER=1 property */
         ret = NULL;
         list = g_udev_client_query_by_subsystem (client, "input");
+        listiio = g_udev_client_query_by_subsystem (client, "iio");
+        list = g_list_concat(list, listiio);
         for (l = list; l != NULL; l = l->next) {
                 GUdevDevice *dev;
 
@@ -408,6 +411,50 @@
         return ret;
 }
 
+static int read_sysfs_attr_as_int(const char *filename) {
+	int i, c;
+	char buf[40];
+	int fd = open(filename, O_RDONLY);
+	if (fd < 0)
+		return 0;
+	c = read(fd, buf, 40);
+	if (c < 0)
+		return 0;
+	close(fd);
+	sscanf(buf, "%d", &i);
+	
+	return i;
+}
+
+#define MPU_THRESHOLD 12000
+#define MPU_POLL_INTERVAL 1
+
+static gboolean mpu_timer(GsdOrientationManager *manager) {
+	int x, y;
+	OrientationUp orientation = manager->priv->prev_orientation;
+
+	x = read_sysfs_attr_as_int(g_build_filename(manager->priv->sysfs_path, "in_accel_x_raw", NULL));
+	y = read_sysfs_attr_as_int(g_build_filename(manager->priv->sysfs_path, "in_accel_y_raw", NULL));
+
+	if (x > MPU_THRESHOLD)
+		orientation = ORIENTATION_NORMAL;
+	if (x < -MPU_THRESHOLD)
+		orientation = ORIENTATION_BOTTOM_UP;
+	if (y > MPU_THRESHOLD)
+		orientation = ORIENTATION_RIGHT_UP;
+	if (y < -MPU_THRESHOLD)
+		orientation = ORIENTATION_LEFT_UP;
+
+        if (orientation != manager->priv->prev_orientation) {
+                manager->priv->prev_orientation = orientation;
+                g_debug ("Orientation changed to '%s', switching screen rotation",
+                         orientation_to_string (manager->priv->prev_orientation));
+
+                do_rotation (manager);
+        }
+	return TRUE;
+}
+
 static gboolean
 gsd_orientation_manager_idle_cb (GsdOrientationManager *manager)
 {
@@ -432,7 +479,13 @@
         g_debug ("Found accelerometer at sysfs path '%s'", manager->priv->sysfs_path);
 
         manager->priv->prev_orientation = get_orientation_from_device (dev);
-        g_object_unref (dev);
+
+	/* Poll the sysfs attributes exposed by MPU6050 as it is not an uevent based input driver */
+	if (g_strcmp0 (g_udev_device_get_sysfs_attr (dev, "name"), "mpu6050") == 0) {
+		g_timeout_add_seconds(MPU_POLL_INTERVAL, (GSourceFunc) mpu_timer, manager);
+	} 
+
+       	g_object_unref (dev);
 
         /* Start process of owning a D-Bus name */
         g_bus_get (G_BUS_TYPE_SESSION,
